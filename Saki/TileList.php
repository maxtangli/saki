<?php
namespace Saki;

use Saki\Util\ArrayReadonlyWrapper;

class TileList extends ArrayReadonlyWrapper {

    static function validString($s) {
        $regex = '/^(([1-9]+[smp])|[ESWNCFP])+$/';
        return preg_match($regex, $s);
    }

    /**
     * @return TileList
     */
    static function fromString($s) {
        if (!static::validString($s)) {
            throw new \InvalidArgumentException();
        }

        $tiles = [];
        $tileType = null;
        for ($i = strlen($s) - 1; $i >= 0; --$i) {
            $c = $s[$i];
            if (is_numeric($c)) {
                array_unshift($tiles, new Tile($tileType, intval($c)));
            } else {
                $tileType = TileType::fromString($c);
                if ($tileType->isHonor()) {
                    array_unshift($tiles, new Tile($tileType));
                }
            }
        }

        return new self($tiles);
    }

    function __construct(array $tiles) {
        parent::__construct($tiles);
    }

    /**
     * @return Tile[]
     */
    protected function getInnerArray() {
        return parent::getInnerArray();
    }

    /**
     * @param int $offset
     * @return Tile
     */
    function offsetGet($offset) {
        return parent::offsetGet($offset); // TODO: Change the autogenerated stub
    }


    function __toString() {
        // 123m456p789s東東東中中
        $s = "";
        $tiles = $this->getInnerArray();
        $len = count($tiles);
        for ($i = 0; $i < $len; ++$i) {
            $tile = $tiles[$i];
            if ($tile->getTileType()->isSuit()) {
                $doNotPrintSuit = isset($tiles[$i + 1]) && $tiles[$i + 1]->getTileType()->isSuit() && $tiles[$i + 1]->getTileType() == $tile->getTileType();
                $s .= $doNotPrintSuit ? $tile->getNumber() : $tile;
            } else {
                $s .= $tile;
            }
        }
        return $s;
    }

    function replace($targetIndex, Tile $tile) {
        $newTiles = $this->getInnerArray();
        $newTiles[$targetIndex] = $tile;
        self::sort($newTiles);
        $this->setInnerArray($newTiles);
    }

    function remove(array $targetIndexes) {
        $newTiles = [];
        foreach ($this->getInnerArray() as $i => $t) {
            $needRemove = array_search($i, $targetIndexes) !== false;
            if (!$needRemove) {
                $newTiles[] = $t;
            }
        }
        $this->setInnerArray($newTiles);
    }
}

